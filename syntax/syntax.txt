Syntax Analysis:

Create a parser to process the tokens and generate an abstract syntax tree (AST). 
The parser should follow the grammar rules defined for the language.


grammar rules:
#STATEMENTS - methods for assign/call/term/return

AFTER BUILDING REGEX FOR BUILTIN FUNCTIONS - ENSURE THAT FUNCTION CALLS CAN ONLY BE DONE WITH KEYWORDS OF THOSE FUNCTIONS
*return statement: type: "return", children: [what to return: literal/identifier/expression/ nothing]
*assign: value of "assign", children: [target: identifier, source: expression/literal/function call]
DONT FORGET TO ALLOW ASSIGNMENT WITH A FUNCTION CALL 

* if statements: if-keyword, children: [condition, body, else block(default=None)]

*LOOPS
    **while: name: while, children: [condition, body: nodes]
    **for: name: for. children: [iterationVar, iterable: array/tupple/function of range, body: nodes]
    
*FUNCTION DEF -still not done
    **function defining: function keyword-type: "functionDef", attr: {function name, args}, children: [body, return statement]



#EXPRESSIONS - Done, deal with extra parenthasis for {}
*boolean expression: value of logical operator, children: [Left operand and right operand: 
    bool or binary expression(might be built from expression like x+3<y or boolean exp)]

    -envolves any logical operator: ==, !=, &&, || !
    -might have one child operand for cases like !x

*condition = boolean identifier, boolean expression

*arithmetic exp: value of operator, children: 
    [left and right operand which are either another expression/ literal/identifier]

#FunctionCall - funcName in the attrs, FunctionCall as type
children: [args]






